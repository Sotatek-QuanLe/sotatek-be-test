# Assumptions

The following assumptions are made within the context of a 4-hour technical assignment.

---

## 1. Business Assumptions

### Order Flow
- An order can contain **multiple products** (shopping cart style).
- Each order consists of multiple **OrderItems**, where each item has a `productId` and `quantity`.
- Order statuses (simplified):
  - `PENDING`: Order created, payment not yet processed.
  - `CONFIRMED`: Payment successful.
  - `CANCELLED`: Order cancelled by the user.
- Order flow: `PENDING` â†’ `CONFIRMED` or `CANCELLED`.
- Both `PENDING` and `CONFIRMED` orders can be transitioned to `CANCELLED`.
- Partial payments or split payments are not supported.
- There is no concept of shipping or delivery within this scope.

### Order Update Rules
- **PUT /api/orders/{id}**: Only allows updating the **status** (specifically to cancel an order).
- Updating other fields (memberId, items) is not permitted.
- Valid transitions: `PENDING` â†’ `CANCELLED`, `CONFIRMED` â†’ `CANCELLED`.
- Once `CANCELLED`, the status cannot be changed further.
- ~~DELETE /api/orders/{id}~~: **Removed from scope**.

### Member
- Members are authenticated at a different layer (API Gateway/Auth Service).
- `memberId` is passed in the request; no JWT/token verification is required within this service.
- Validation is limited to checking if the member **exists** and their status is **ACTIVE**.

### Product & Inventory
- Stock checks are **point-in-time** validations and do not lock inventory.
- Race conditions handling (when multiple orders are placed simultaneously) is not implemented, assuming **low traffic**.
- Prices are retrieved from the Product Service at the time of order creation (snapshot pricing).

### Payment
- Payment is **synchronous** - responses are immediate (COMPLETED or FAILED).
- Asynchronous payment callbacks/webhooks are not handled.
- Refund flow is not implemented.

---

## 2. Technical Assumptions

### Database
- **H2 in-memory database** is used for development and demonstration purposes.
- Schema is automatically generated by Hibernate (`ddl-auto: create-drop`).
- Database migration scripts (Flyway/Liquibase) are not required.

### External Services
- External services (Member, Product, Payment) are **mocked within the code**.
- Mocks return deterministic responses based on input.
- A separate WireMock server is not set up.

### API Design
- All APIs are synchronous (blocking).
- Pagination uses offset-based parameters (`page`, `size`).
- A unified response format is used for both success and error scenarios.

### Security
- **Authentication/authorization is not implemented** within this scope.
- It is assumed that requests are authenticated at the API Gateway layer.
- Input validation/sanitization for SQL injection is handled by JPA.

---

## 3. Data Assumptions

### IDs
- **Auto-generated Long IDs** are used for the Order entity.
- External IDs (`memberId`, `productId`) are treated as Strings.

### Validation
- `memberId`: required, non-empty.
- `items`: required, non-empty array (at least 1 item).
  - `items[].productId`: required, non-empty.
  - `items[].quantity`: required, positive integer (> 0).
- `paymentMethod`: required, enum: `CREDIT_CARD`, `DEBIT_CARD`, `BANK_TRANSFER`.

### Timestamps
- `LocalDateTime` with UTC timezone is used.
- `createdAt` and `updatedAt` are automatically managed.

---

## 4. Out of Scope

The following features were **not implemented** in this assignment:

- [ ] Multi-item orders (cart with multiple distinct products) - *Clarification: The data model supports it but complex cart logic might be out of scope.*
- [ ] Inventory reservation/locking
- [ ] Async payment processing
- [ ] Order history/audit log
- [ ] Email/notification service
- [ ] Rate limiting
- [ ] Caching (Redis)
- [ ] Distributed tracing
- [ ] Health check endpoints (beyond basic actuator)
- [ ] Containerization (Docker)

---

## 5. Mock Service Behavior

### Member Service Mock
| Input | Response |
|-------|----------|
| `memberId` exists | `200 OK` - member details |
| `memberId` = "inactive-member" | `200 OK` - status: INACTIVE |
| `memberId` = "not-found" | `404 Not Found` |
| `memberId` = "error" | `500 Internal Server Error` |

### Product Service Mock
| Input | Response |
|-------|----------|
| `productId` exists | `200 OK` - product details |
| `productId` = "out-of-stock" | `200 OK` - stock: 0 |
| `productId` = "discontinued" | `200 OK` - status: DISCONTINUED |
| `productId` = "not-found" | `404 Not Found` |

### Payment Service Mock
| Input | Response |
|-------|----------|
| Valid payment request | `200 OK` - status: COMPLETED |
| `paymentMethod` = invalid | `400 Bad Request` |
| Amount > 10000 | `200 OK` - status: FAILED (simulate decline) |

---

## 6. Error Handling Strategy

- **4xx errors**: Client errors - validation failed, resource not found.
- **5xx errors**: Server errors - external service unavailable, unexpected exceptions.
- All errors return a unified format:
  ```json
  {
    "error": "ERROR_CODE",
    "message": "Human readable message",
    "timestamp": "2024-01-15T10:30:00Z"
  }
  ```

---

## 7. Assumptions Risk Assessment (Self-Critique)

> *"An assumption is a liability until proven otherwise."*

### 7.1 Risk Matrix

| Assumption | Category | Risk Level | Failure Mode |
|------------|----------|------------|--------------|
| Low traffic | Business | ðŸ”´ CRITICAL | Race condition â†’ overselling |
| Sync payment | Technical | ðŸ”´ CRITICAL | Timeout â†’ stuck orders |
| No refund flow | Business | ðŸŸ  HIGH | Chargebacks, complaints |
| Mock = Real behavior | Technical | ðŸŸ  HIGH | Production failures |
| H2 in-memory | Technical | ðŸŸ¡ MEDIUM | Data loss on restart |
| No auth | Security | ðŸŸ¡ MEDIUM | Fraud, unauthorized orders |
| Point-in-time price | Business | ðŸŸ¡ MEDIUM | Price disputes |

### 7.2 Critical Assumptions Deep Dive

#### ðŸ”´ "Low Traffic" - The Most Dangerous Assumption

```
Why we made it:
- Simplifies implementation
- Avoids distributed locking complexity
- Saves 30+ minutes of coding

Why it's dangerous:
- Traffic is unpredictable
- Marketing campaigns, viral moments
- Single viral tweet = 10,000x traffic spike

What breaks:
- Stock check race condition
- Duplicate order creation
- Payment double-charge

Production fix needed:
- Redis distributed lock on (productId + stock operation)
- Idempotency key for order creation
- Pessimistic DB locking for critical sections
```

#### ðŸ”´ "Synchronous Payment" - Ticking Time Bomb

```
Why we made it:
- Simpler request/response flow
- No webhook infrastructure needed
- Easier to test and debug

Why it's dangerous:
- Real payment gateways timeout (30s+)
- Network issues cause hanging requests
- Thread pool exhaustion under load

What breaks:
- User sees "loading" forever
- Order status inconsistent
- Double charges on retry

Production fix needed:
- Async payment initiation
- Webhook for payment confirmation
- Polling endpoint for status check
- Timeout + retry with idempotency
```

#### ðŸŸ  "No Refund on Cancel" - Customer Trust Killer

```
Why we made it:
- Out of scope per time constraint
- Simplifies cancel logic
- Avoids Payment Service complexity

Why it's dangerous:
- CONFIRMED order has money charged
- Cancel without refund = angry customer
- Chargeback = penalty fees + reputation damage

What breaks:
- Customer trust
- Legal compliance (depending on jurisdiction)
- Support ticket flood

Production fix needed:
- PaymentClient.refund(orderId, amount)
- Partial refund support
- Refund status tracking
- Notification to customer
```

### 7.3 Assumptions That Are Actually OK

| Assumption | Why It's Acceptable |
|------------|---------------------|
| Single order service instance | Demo scope, horizontal scaling is deployment concern |
| No caching | Premature optimization, add when needed |
| No distributed tracing | Nice-to-have, not blocking |
| Offset pagination | Works fine for <100k records |
| UTC timestamps | Industry standard, correct choice |
| Auto-generated IDs | Simple, works for most cases |

### 7.4 Questions Interviewer Might Ask

| Question | Expected Answer |
|----------|-----------------|
| "What if 2 users order the last item?" | "Race condition - I'd add Redis lock in production" |
| "What if payment takes 30 seconds?" | "Current design will timeout - async + webhook needed" |
| "What happens to refund on cancel?" | "Not implemented - would add PaymentClient.refund()" |
| "Why H2?" | "Demo purpose - production would use PostgreSQL/MySQL" |
| "How do you prevent duplicate orders?" | "Missing idempotency key - production must have it" |

> **Self-awareness > Perfect design**: Interviewer values candidates who understand their design's limitations.
